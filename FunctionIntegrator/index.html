<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/pure.css"> <link rel=stylesheet  href="/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>FunctionIntegrator.jl</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Pure-SM</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/menu1/" class=pure-menu-link >Code blocks</a> <li class="pure-menu-item "><a href="/menu2/" class=pure-menu-link >More goodies</a> <li class="pure-menu-item "><a href="/menu3/" class=pure-menu-link >Tags</a> </ul> </div> </div> <div id=main > <div class=header > <h1>FunctionIntegrator.jl</h1> <h2>Using the Pure/Side-Menu template</h2> </div> <div class=franklin-content ><p><img src="https://travis-ci.com/fusion809/FunctionIntegrator.jl.svg?branch&#61;master" alt=Travis  /> <img src="https://github.com/fusion809/FunctionIntegrator.jl/workflows/CompatHelper/badge.svg?event&#61;push" alt=CompatHelper  /></p> <p>This package should be treated as a second-rate alternative to the excellent <a href="https://github.com/JuliaMath/QuadGK.jl">QuadGK</a> package. QuadGK provides more accurate integration for many problems, and also provides an error estimate which functions in this package do not.</p> <p>This package provides the following functions:</p> <ul> <li><p><code>chebyshev_quadrature&#40;f::Function, N::Number, k::Integer, a::Number, b::Number&#41;</code></p> <li><p><code>hermite_quadrature&#40;f::Function, N::Number, k::Integer&#41;</code></p> <li><p><code>jacobi_quadrature&#40;f::Function, N::Number, α::Number, β::Number, a::Number, b::Number&#41;</code></p> <li><p><code>laguerre_quadrature&#40;f::Function, N::Number, k::Integer&#41;</code></p> <li><p><code>legendre_quadrature&#40;f::Function, N::Number, a::Number, b::Number&#41;</code></p> <li><p><code>lobatto_quadrature&#40;f::Function, N::Number, a::Number, b::Number&#41;</code></p> <li><p><code>radau_quadrature&#40;f::Function, N::Number, a::Number, b::Number&#41;</code></p> <li><p><code>rectangle_rule&#40;f::Function, N::Number, a::Number, b::Number&#41;</code></p> <li><p><code>simpsons_rule&#40;f::Function, N::Number, a::Number, b::Number&#41;</code></p> <li><p><code>trapezoidal_rule&#40;f::Function, N::Number, a::Number, b::Number&#41;</code></p> </ul> <p>use Julia&#39;s help function &#40;e.g. by typing <code>?chebyshev_quadrature</code>&#41; to find out usage information, should you need it.</p> <p>This package is not currently in Julia&#39;s registries, so to install it one has to run:</p> <pre><code class="julia hljs">pkg&gt; add git://github.com/fusion809/FunctionIntegrator.jl.git</code></pre>
<p>Although, a <a href="https://github.com/JuliaRegistries/General/pull/16929">pull request</a> to add this package to the <a href="https://github.com/JuliaRegistries/General">&quot;General&quot; registry</a> is currently open, so hopefully soon this will no longer be necessary.</p>
<h2 id=choice_of_function ><a href="#choice_of_function">Choice of function</a></h2>  As a general rule of thumb, <code>simpsons_rule</code> should be the function you use when you&#39;re unsure which function to use as its approximations with large N &#40;e.g. 1e8&#41; are nearly always accurate to at least 6 digits. Despite this, for many problems some of the <code>_quadrature</code> functions may provide more accurate results with a far smaller N value. The main time when <code>simpsons_rule</code> should be avoided is when there are singularities at the endpoints of the domain of integration, in which case using <code>chebyshev_quadrature</code> with k&#61;1 or using <code>legendre_quadrature</code> is likely best.</p>
<p>Each of the functions whose name ends with <code>_quadrature</code> uses <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gaussian quadrature</a>, the specifics of which differ between functions. Out of them, <code>chebyshev_quadrature</code> and <code>legendre_quadrature</code> are perhaps the best to go with when you&#39;re uncertain which out of the <code>_quadrature</code> functions to go with as they can be applied to any grid and any problem and <em>usually</em> arrive at a result that is accurate to at least 4 decimal places provided N&geq;1e6. These two functions have the added benefit of being faster than all other <code>_quadrature</code> functions, after controlling for N.</p>
<p>The <a href="test/">test/</a> folder has test scripts that approximate various different integrals &#40;each file, except <a href="test/runtests.jl">test/runtests.jl</a>, pertains to a different integral&#41;; the N values given are the smallest possible to pass each of the tests listed &#40;except when the test involves a less than &#40;&lt;&#41; sign&#41;. If you want to know which function to use for which integral, these tests may be useful as a rough guide.</p>
<table><tr><th align=right >Function<th align=right >Domain of integration<th align=right >Arguments<th align=right >Notes<tr><td align=right ><code>chebyshev_quadrature</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>k</code>, the type of Chebyshev quadrature being used. 1, 2, 3, and 4 refer to the Chebyshev T, U, V and W polynomials respectively.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >Out of <code>_quadrature</code> functions, it or <code>legendre_quadrature</code> are favoured for most problems.<tr><td align=right ><code>hermite_quadrature</code><td align=right >&#91;-∞,∞&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>k</code> determines the problem being solved &#40;whether e^&#40;-x^2&#41; is assumed to be part of the integrand &#40;k&#61;2&#41; or not&#41;.<td align=right >Only use this if your integration domain is &#91;-∞,∞&#93; and your integrand converges rapidly.<tr><td align=right ><code>jacobi_quadrature</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>α</code> and <code>β</code> are parameters of the weighting function.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >Potentially useful when the integrand includes powers of &#40;1-x&#41; and &#40;1&#43;x&#41;, as these are parts of the weighting function.<tr><td align=right ><code>laguerre_quadrature</code><td align=right >&#91;0,∞&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>k</code> determines the problem being solved &#40;whether e^&#40;-x&#41; is assumed to be part of the integrand &#40;k&#61;2&#41; or not&#41;.<td align=right >Only use this if your integration domain is &#91;0,∞&#93; and your integrand converges rapidly.<tr><td align=right ><code>legendre_quadrature</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >Generally, this is the best <code>_quadrature</code> function to go with when you&#39;re otherwise unsure which to go with.<tr><td align=right ><code>lobatto_quadrature</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >This function includes, in the calculation, the values of the function at the endpoints. Consequently, if there are singularities at either or both of the endpoints, this function will fail to give an accurate result even if you adjust the endpoints slightly to avoid the singularities.<tr><td align=right ><code>radau_quadrature</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >This function includes, in the calculation, the values of the function at the endpoints. Consequently, if there are singularities at either or both of the endpoints, this function will fail to give an accurate result even if you adjust the endpoints slightly to avoid the singularities.<tr><td align=right ><code>rectangle_rule</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >Usually this is the least accurate method.<tr><td align=right ><code>simpsons_rule</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >One of the best functions to use when you&#39;re unsure which to use.<tr><td align=right ><code>trapezoidal_rule</code><td align=right >&#91;a,b&#93;<td align=right ><code>f</code>, the function being integrated.&lt;br/&gt;<code>N</code>, the number of grid points.&lt;br/&gt;<code>a</code>, the start of the domain of integration.&lt;br/&gt;<code>b</code>, the end of the domain of integration.<td align=right >Usually this is the second-least accurate method.</table>
<h2 id=acknowledgements ><a href="#acknowledgements">Acknowledgements</a></h2>  I&#39;d like to thank the Julia discourse community for their generous help through my Julia journey, and I would also like to thank the developers of  Julia, as without their work this package would not even be possible &#40;I know, obviously, as this is a Julia package&#41;. Likewise, I&#39;d also like to thank the developers of <a href="https://github.com/JuliaApproximation/FastGaussQuadrature.jl">FastGaussQuadrature.jl</a>, as without their efficient algorithms for finding the nodes and weights for various Gaussian quadrature techniques, several of the functions in this repository would be far less efficient &#40;especially <code>legendre_quadrature</code>&#41;, or may not even exist. I&#39;d also like to thank the developers of <a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a>, as some of their functions are useful for testing the functions in this package.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Brenton Horne. Last modified: June 27, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div>
      </div> 
  </div> 
  <script src="/libs/pure/ui.min.js"></script>